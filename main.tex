\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.

\usepackage[english]{babel}
\usepackage{amsthm}
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\usepackage[a4paper, total={184mm,239mm}]{geometry}
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}

\theoremstyle{definition}
\newtheorem{definition}{Definition}

\usepackage{listings}
\usepackage{stfloats}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{xcolor}
% \usepackage[fleqn]{amsmath}
\usepackage{lstautogobble}  % Fix relative indenting
\usepackage{color}          % Code coloring
\usepackage{zi4}            % Nice font

\definecolor{bluekeywords}{rgb}{0.13, 0.13, 1}
\definecolor{graycomments}{rgb}{0.5, 0.5, 0.5}
\definecolor{redstrings}{rgb}{0.9, 0, 0}
\definecolor{graynumbers}{rgb}{0.5, 0.5, 0.5}

\lstset{
    autogobble,
    columns=fullflexible,
    showspaces=false,
    showtabs=false,
    breaklines=true,
    showstringspaces=false,
    breakatwhitespace=true,
    escapeinside={(*@}{@*)},
    commentstyle=\color{graycomments},
    keywordstyle=\color{bluekeywords},
    stringstyle=\color{redstrings},
    numberstyle=\color{graynumbers},
    basicstyle=\ttfamily,
    xleftmargin=18pt,
    xrightmargin=2pt,
    tabsize=4,
    captionpos=b
}
\lstset
{ %Formatting for code in appendix
    language=Matlab,
    % basicstyle=\footnotesize,
    numbers=left,
    stepnumber=1,
    showstringspaces=false,
    tabsize=1,
    breaklines=true,
    breakatwhitespace=false,
}
\lstset{
numbers=left, 
numberstyle=\small, 
numbersep=8pt, 
frame = single, 
language=Pascal, 
framexleftmargin=15pt}

\pagestyle{empty}
\begin{document}

\title{ChiselFV: A Formal Verification Framework for Chisel
% {\footnotesize \textsuperscript{*}Note: Sub-titles are not captured in Xplore and
% should not be used}
% \thanks{Identify applicable funding agency here. If none, delete this.}
}


\maketitle

% 现代硬件设计越来越复杂 -> 敏捷开发技术 -> Chisel -> Formal for Chisel -> ChiselFV
\begin{abstract}
    Modern digital hardware is becoming ever more complex. And agile development, an efficient idea in software development, has been introduced into hardware. Furthermore, as a new hardware construction language, Chisel helps to raise the level of hardware design abstraction with the support of object-oriented and functional programming. Chisel plays a crucial role in future hardware design and open-source hardware development. However, the formal verification for Chisel is still limited. In this paper, we propose ChiselFV, a formal verification framework that has supported detailed formal hardware property descriptions and integrated mature formal hardware verification flows based on SymbiYosys. It builds on top of Chisel and uses Scala to drive the verification process. Thus the framework can be seen as an extension of Chisel. ChiselFV makes it easy to verify hardware designs formally when implementing them in Chisel.
\end{abstract}

\begin{IEEEkeywords}
    Hardware verification, Formal methods, Hardware description language, Chisel
\end{IEEEkeywords}

\section{Introduction}
% 硬件设计需求复杂，Chisel 出现，Chisel 优势
Over the past several years, hardware design has grown to be ever more and more complex. The increased demand for high-performance computing systems has led to a larger need for domain-specific hardware accelerators \cite{dally2020domain}.
The dominant traditional hardware description languages (HDLs), Verilog and VHDL, were initially developed as hardware simulation languages and were only later adopted as a basis for hardware synthesis. So these languages lack the powerful abstraction facilities that are common in modern software languages, which leads to low productivity because it is difficult to reuse components.
Chisel \cite{bachrach2012chisel}, a Scala-embedded hardware construction language, was introduced in order to lift digital circuit description to a more software-like high-level language \cite{dobis2021chiselverify}.
Chisel attempts to solve these problems by providing functional and object-oriented programming support. With these features, Chisel supports advanced hardware design using highly parameterized generators and improves the abstraction level of hardware design. However, Chisel lacks the powerful and easy-to-use formal verification support that is mature in traditional HDLs.

% 硬件验证必要性，Chisel 上的形式化验证工作不足 + 无法直接迁移
In hardware development, because of the high cost of trial and error, verifying the correctness of the design is essential, especially for trusted systems which are constantly dealing with human lives or may cause a massive loss if an unexpected event occurs. Therefore, we need to use many test cases to simulate the design to find bugs and use formal methods to ensure correctness. There are many mature verification methods in traditional hardware languages. However, in Chisel, the work of formal verification is still limited, and the previous workflow for low level RTL cannot be migrated to Chisel easily.

% Chisel 上的验证工作：ChiselVerify + 官方的 Chisel Formal 支持。相比成熟的 HDLs 的形式化支持，这些都是比较原始的。 
Currently, there is some work on the Chisel level to verify the correctness of the design. ChiselVerify is a verification framework inspired by Universal Verification Method(UVM) \cite{mehta2018uvm} and implemented on the Chisel level and supports both coverage-oriented and constrained random verification (CRV) flows \cite{dobis2021chiselverify}. However, ChiselVerify only focuses on applying software testing techniques to hardware verification.
Recently, Berkeley provided Chisel developers with an easy way to formally verify the designs \cite{dobis2021open}. They added a formal backend to the FIRRTL compiler, which converts a high-level intermediate representation (IR) into a normalized structural representation. The backend can translate FIRRTL expressions to the bit-vector expression language defined by the SMTLib format \cite{barrett2010smt}, and then use the Z3 solver \cite{moura2008z3} to execute the Bounded Model Checking (BMC) algorithm \cite{biere2009bounded}.
% 然而目前它支持的性质描述十分有限，仅支持对返回为 Boolean 类型值的表达式断言，而且支持的验证方法也只有 BMC。和现有的低层次 HDL 的形式化支持相比，它显得十分初级。
However, the current support for property description is very limited. It only supports assertions on expressions that return Boolean values, and the verification algorithm it supports is only BMC. Compared with the existing formal support for other HDLs, they are very primitive.

% 传统 HDLs 中的方案中，SVA 描述强大，验证方案丰富。但是迁移有问题：生成的代码可读性差，参数化。
% 在传统的硬件设计语言中，有着成熟的硬件验证技术支持，但是无法直接迁移到 Chisel 中。
Traditional HDLs have mature hardware verification techniques, but they cannot be directly migrated to Chisel.
% 例如，可以使用 SystemVerilog Assertions（SVA）来描述性质。它支持复杂的时序性质描述。它可以和 SystemVerilog 代码一起被 Yosys 工具综合，转化为迁移系统，使用 SAT / SMT 求解器为基础的各种模型检测算法求解。
For example, SystemVerilog Assertions (SVA) \cite{vijayaraghavan2005practical} can be used to describe properties. SVA is a essentially a language construct which provides a powerful way to write constraints, checkers, and cover points for hardware designs. It supports complex temporal property descriptions. It can be synthesized with SystemVerilog code by Yosys \cite{wolf2016yosys} and converted to a transition system, which can be solved by various model checking algorithms based on SAT/SMT solvers.
% 目前 Chisel 语言主要用于在高层构造硬件生成器，然后生成 SystemVerilog 代码用于综合。在生成 SystemVerilog 中定义性质描述时不可行的，一方面生成的 SystemVerilog 代码可读性很差，设计复杂时，很难找到 Chisel 中对应的信号，因此很难在这里添加性质描述；同时，Chisel 的优势在于高度参数化，但是在 SystemVerilog 层次已经完成了 Chisel 模块的实例化，因此需要在每次实例化时重新定义性质，这是不可取的。
Currently, Chisel is mainly used to construct hardware generators at the high level and then generate SystemVerilog code for synthesis. It is not feasible to define property descriptions in SystemVerilog, because the generated SystemVerilog code is difficult to read, making it hard to find the corresponding signals in Chisel when the design is complex. In addition, Chisel's advantage is high parameterization, but in the generated SystemVerilog, the module instantiation has been completed, so the property needs to be redefined every time the module is instantiated, which is not desirable.

% 所以我们的工作就是把传统 HDLs 中的验证能力在 Chisel 层次进行实现
% 因此我们选择直接在 Chisel 上进行性质定义，并且致力于使 Chisel 具有和传统 HDLs 相同能力的形式化支持。
Therefore, we choose to define properties directly on Chisel and strive to make Chisel have the same formal support as traditional HDLs. 
Our main contribution in this paper is to propose ChiselFV, a formal verification framework for Chisel, which can be found in the GitHub repository \cite{ChiselFV}.
We also provide the workflow of formal verification on the Chisel level and detailed application of ChiselFV on the actual case. The contribution of this work is as follows:

\begin{itemize}
    \item \textbf{ChiselFV.} We propose a formal verification framework for Chisel, which can be used to describe hardware properties on the Chisel level. And we integrated the verification algorithm engine to perform verification in one-click. At the same time, our ChiselFV has the ability to describe the temporal properties and the ability to describe the free constant definition, which greatly enhanced the hardware properties description capability.
    \item \textbf{High-efficiency verification flow.} We propose a hardware verification workflow based on ChiselFV. With ChiselFV, we can synchronize the hardware properties description with the agile development process, thereby avoiding the design of complicated hardware properties in the low-level hardware. The hardware verification flow can be integrated into the agile hardware development process seaminglessly. 
    % 我们用多端口内存的正确性验证和一个教科书上的五级流水线设计验证来说明这点。
    We use the formal verification process of a multi-ported memory and a textbook five-stage pipeline design to illustrate this point.
\end{itemize}

This paper is organized into five sections. Section II uses Memory's example to explain the apparent advantages of formal verification on the Chisel level. Section III details ChiselFV and the workflow of formal verification on Chisel modules. Section IV describes how to verify multi-ported Memory using ChiselFV. Related work is in Section V. Section VI concludes.

\section{A Motivating Example}
In this section, we use a case to demonstrate the advantages of formal verification on the Chisel level.

% 内存是硬件中重要的一个部分，在 Chisel 中，提供了直接构造内存的库，从而使得我们可以很方便地得到一个参数化大小和位宽的内存模块。
Memory is an important part of hardware development, and Chisel provides a library to construct Memory directly, making it easy to get a memory module with a parameterized size and width.
% 可以看到，我们使用 15 行代码得到参数化内存。
We can quickly use 15 lines to get a parameterized memory in Chisel.

\begin{lstlisting}[language=scala, caption={A memory of size c and width w in Chisel}, label=mem]
class Memory(c: Int, w: Int) extends Module {
    val nw = log2Ceil(c)
    val io = IO(new Bundle {
        val wrEna = Input(Bool())
        val wrData = Input(UInt(w.W))
        val wrAddr = Input(UInt(nw.W))
        val rdAddr = Input(UInt(nw.W))
        val rdData = Output(UInt(w.W))
    })
    val mem = Mem(c, UInt(w.W))
    when(io.wrEna) {
        mem.write(io.wrAddr, io.wrData)
    }
    io.rdData := mem.read(io.rdAddr)
}
\end{lstlisting}

As shown in Listing \ref{mem}, this is a parameterized memory implemented in Chisel. The module has two constructor parameters, \verb|c| and \verb|w|, where \verb|c| is the size of the Memory, and \verb|w| is the width of the data in the Memory. We define the IO of the module (line 3-9), Memory (line 10), and read / write access  (line 11-14). It is easy to construct such a parameterized module in Chisel, but it is hard in SystemVerilog to define a resizeable memory module.

Next, we need to verify the correctness of the memory module. First, we need to describe the properties of the memory module in non-formal language: At any time, any address can write data, and after any time, if no write operation is performed on the address, the data read from the address should be the data written before. Then we need to convert the properties to a formal expression and package it with the memory module.
% 然而在当前的 Chisel 的形式化描述支持中，无法将上面的性质定义出来，因为这里需要一个定义一个任意值来描述地址或数据。
However, in the current Chisel formal support, the above properties cannot be defined, because here we need to define an arbitrary value to describe the address or data.

% 我们可以试着在 Chisel 上设计模块，然后在生成的 SystemVerilog 代码上进行形式化验证。
We can try to design the module on Chisel and then perform formal verification on the generated SystemVerilog code.
% Chisel 模块可以很容易生成对应的 SystemVerilog 代码，例如可以使用 Listing 2 中的代码块来实例化一个 1KB 的 Memory 模块。
Chisel modules can easily generate corresponding SystemVerilog code. For example, we can use the code in Listing \ref{initializememory} to instantiate a 1KB Memory module.

\begin{lstlisting}[language=Scala, caption={A Chisel code fragment using to instantiate 1KB Memory module in SystemVerilog}, label={initializememory}]
chisel3.stage.ChiselStage.emitSystemVerilog(new Memory(1024, 8))
\end{lstlisting}

% 然而，利用 Chisel 生成的低层次 RTL 进行形式化验证是繁琐且几乎不可行的。
However, using the low-level RTL generated by Chisel to perform formal verification is tedious and almost impossible. 
% 首先，Chisel 生成的低层次 RTL 可读性十分差。15 行的 Chisel 代码实例化得到的 SystemVerilog 代码有 80 行。同时如 Listing 3 所示的，生成的 SystemVerilog 中的变量名会被污染。Chisel 的编译过程是不去考虑生成电路的可读性的，因此在生成的低层次 RTL 中分析验证是不可取的。
First, the readability of the low-level RTL generated by Chisel is poor. The 15-line Chicodesode generates 80 lines of SystemVerilog code. As shown in Listing \ref{svcode}, the variable names in the generated SystemVerilog are polluted. Chisel's compilation process does not consider the readability of the generated circuit, so it is not appropriate to analyze and verify the generated low-level RTL.
% 其次，对于生成的 SystemVerilog 内存模块，其大小和宽度都确定了，不能参数化地定义性质，所以当参数发生变化了，我们需要重新编写性质描述来验证，这是低效率的。
Second, for the generated SystemVerilog memory module, its size and width are fixed, so we cannot parameterize the properties. When the parameters change, we need to rewrite the property description to verify it, which is inefficient. 

\begin{lstlisting}[language=Verilog, caption={A SystemVerilog code fragment generated by Chisel}, label={svcode}]
...
assign mem_MPORT_en = io_wrEna;
assign io_rdData = mem_io_rdData_MPORT_data; // @[Memory.scala 19:13]
always @(posedge clock) begin
    if (mem_MPORT_en & mem_MPORT_mask) begin
    mem[mem_MPORT_addr] <= mem_MPORT_data; // @[Memory.scala 14:16]
    end
end
...
\end{lstlisting}

\section{Formal Verification in Chisel}

This section gives the structure of ChiselFV, details the property description and algorithm engine support in ChiselFV and the methodology to perform formal verification on Chisel using ChiselFV.

\subsection{Framework Structure}

ChiselFV is based on Chisel and can be seen as an extension of formal verification in Chisel. The primary implementation uses Scala and enables Chisel modules to provide property descriptions and formal verification. The figure Fig \ref{fig: structure} shows the structure of ChiselFV.

\begin{figure}[!htbp]
    \begin{center}
    \includegraphics[width=1\linewidth]{pics/structure.png}
    \caption{ChiselFV Structure}
    \label{fig: structure}
    \end{center}
\end{figure}

As shown in Fig \ref{fig: structure}, ChiselFV is mainly an extension of Chisel's SystemVerilog generation and adds support for formal verification syntax. It also integrates the verification frontend and backend based on SymbiYosys, enabling one-key verification. The SystemVerilog generation is performed by calling the SystemVerilog generation process in Chisel. In contrast, for property descriptions, the compilation of the corresponding SystemVerilog Assertions (SVA) script is performed, and some auxiliary circuits, in order to implement more complex property descriptions. And the configuration generator generates SymbiYosys-supported verification tasks configuration file .sby. 

Hardware developers can construct hardware modules in Chisel and Chisel's compiler can compile Chisel modules to SystemVerilog code, and the starting point of our work is of injecting support for formal property descriptions in this stage.
Besides the SystemVerilog generation, we also add support for generating SystemVerilog Assertions and verification configuration files.

\begin{figure}[!htbp]
    \begin{center}
    \includegraphics[width=0.9\linewidth]{pics/ChiselFVSubstitute.png}
    \caption{Technique in Chisel Compilation Extensions}
    \label{fig: ChiselFVSubstitute}
    \end{center}
\end{figure}

As shown in Fig \ref{fig: ChiselFVSubstitute}, we mainly use two techniques to extend the Chisel compilation process. The first is to use the Chisel hardware description abilities to implement the hardware code fragments that are equivalent to the property descriptions, and encapsulate them into functions, providing an interface to call. Through this way, we implement a part of the formal property description syntax support.
% 例如后文中介绍的对于时序性质的支持，主要就是通过封装调用 Chisel 中提供的 \verb|ShiftRegister| 实例来实现的。
Such as to achieve the support for the temporal property description, which introduced in the following section, we mainly try to encapsulate the \verb|ShiftRegister| instance provided by Chisel into a function, and provide an interface to call.

% 利用函数封装，提供接口的方式有一定的局限性，它要求保证性质的描述可以用 Chisel 提供的硬件描述能力来实现，而我们采用的第二种方式，动态模版，则是更加灵活。
Using function encapsulation, and providing interfaces, there is a certain limitation in it, which needs to ensure that the property description can be implemented by Chisel's hardware description abilities, and the second technique, dynamic template, is more flexible.
% 动态模版主要依赖于 Chisel 提供的 \verb|BlackBox| 类，通过编写 SystemVerilog 代码片段，并通过让其继承 \verb|BlackBox| 将其封装为一个新的 Chisel 模块，其将在 Chisel 模块编译时进行注入。同时在编写 SystemVerilog 片段时可以将外部的参数传入到该片段中，从而在编译时，模版会自动应用这些参数进行动态地实例化。
Dynamic template mainly depends on the \verb|BlackBox| class provided by Chisel. We write SystemVerilog code fragments and encapsulate them into a new Chisel module by inheriting \verb|BlackBox|, and they will be injected into the Chisel module during compilation. At the same time, we can pass external parameters to the code fragment, and the template will automatically apply them to the instance dynamically during compilation.

% 最后，我们提供了验证配置文件的自动生成。
Finally, we provide the automatic generation of verification configuration files.
% ChiselFV 可以根据用户指定的验证方法和参数，生成对应的验证配置文件。这里主要采用了 sby 格式，它是由 SymbiYosys 支持。 ChiselFV 同时可以自动调用后端求解算法来根据具体的验证算法和参数，来对生成的模型进行验证。
ChiselFV can generate the corresponding verification configuration file according to the verification algorithm and parameters specified by the user. Here we use .sby format, which is supported by SymbiYosys \cite{SymbiYosys}. ChiselFV can also automatically call the backend algorithm to verify the hardware model according to the specific verification algorithm and parameters.

\subsection{Formal Description Syntax}

% 下面我们给出在 ChiselFV 中支持的性质描述语法的定义。
We give the definition of the property description syntax supported by ChiselFV in Fig \ref{fig: syntax}.
The basic verification task in ChiselFV is: when the assumption defined in \verb|assume| block is true, whether the circuit assertion defined in \verb|assert| block is true or not. 

\begin{figure}[!htbp]
\begin{center}
\begin{equation*}
\begin{aligned}
    \langle \text{ChiselData} \rangle &::= \text{circuit node in Chisel} \\
    \langle \text{num} \rangle &::= \text{nonnegative integer} \\
    \langle \text{anyConst} \rangle &::= \text{circuit node with any constant value} \\ & \qquad \text{defined by Chisel extension support } \\
    \langle \text{valueExpr} \rangle &::= \text{past(} \langle \text{valueExpr} \rangle \text{, } \langle \text{num} \rangle \text{)} | \langle \text{ChiselData} \rangle \\ 
    & \qquad | \langle \text{anyConst} \rangle \\
    \langle \text{comparisonOp} \rangle &::= \text{`} \neq \text{'} \ | \text{`} = \text{'} \ | \ \text{`} < \text{'} \ |\ \text{`} \le \text{'} \ | \ \text{`} > \text{'} \ | \ \text{`} \ge \text{'}  \\
    \langle \text{logicalOp} \rangle &::= \text{`} \&\&\text{'} | \ \text{`} || \text{'} \\
    \langle \text{booleanExpr} \rangle &::=   \langle \text{valueExpr} \rangle \langle \text{comparisonOp} \rangle \langle \text{valueExpr} \rangle\\
    & \qquad |\langle \text{booleanExpr} \rangle \langle \text{logicalOp} \rangle \langle \text{booleanExpr} \rangle \\
    & \qquad | \text{`!'} \langle \text{booleanExpr} \rangle \\  
    & \qquad |  \text{`true.B'} | \text{`false.B'} \\
    \langle \text{assumption} \rangle &::= \text{assume(} \langle \text{booleanExpr} \rangle ) \\
    \langle \text{assertion} \rangle     &::= \text{assert(} \langle \text{booleanExpr} \rangle \text{)} \\
    & \qquad | \text{assertNextStepWhen(} \\ 
    & \langle \text{booleanExpr} \rangle \text{, } \langle \text{booleanExpr} \rangle \text{)} \\ 
    & \qquad | \text{assertAfterNStepWhen(} \\
    & \langle \text{booleanExpr} \rangle \text{, } \langle \text{num} \rangle \text{, } \langle \text {booleanExpr} \rangle \text{)} \\
    & \qquad | \text{assertAlwaysAfterNStep(} \\
    & \langle \text{booleanExpr} \rangle \text{, } \langle \text{num} \rangle \text{, } \langle \text {booleanExpr} \rangle \text{)} \\
\end{aligned}
\end{equation*}
\end{center}
\caption{Syntax of Property Descriptions}
\label{fig: syntax}
\end{figure}

% 对于电路的性质定义，基本上继承在 Chisel 中的语法，对于 Chisel 中返回值为 \verb|Bool| 的数据节点可以作为性质描述（定义为 \langle booleanExpr \rangle），它可以由数据变量之间的比较结果构成。
For the property definition, the basic syntax is inherited from Chisel. It means that the data nodes with return type \verb|Bool| in Chisel can be defined as property descriptions (defined as $\langle \text{booleanExpr} \rangle$ here), which can be constructed by the comparison results between data variables (defined as $\langle \text{valueExpr} \rangle$ here).

% 同时，我们还主要增强了对时序性质的描述支持，以及对自由常量的支持。接下来给出详细介绍。
In addition, we mainly enhance the description support for temporal properties and free constants. The following gives a detailed introduction.

\subsubsection{Immediate Assertions}
% ChiselFV 支持基本的断言类型。
ChiselFV supports the basic immediate assertion types:
\begin{itemize}
  % assume(<expr>): 当进行形式化验证时，所以的 assumeptions 都假设为真，从而可以用于手动缩小验证模型系统的规模。其中 |<expr>| 可以是 Chisel 中的任意返回为 |Bool| 的表达式。
  \item[a.] \verb|assume(expr)|: \\ When performing formal verification, all assumptions are assumed to be true and can be used to shrink the verification model. The expression \verb|expr| can be any expression in Chisel that returns a \verb|Bool|.
  % assert(<expr>): 断言即在形式化验证时检查的内容，模型检查引擎会尝试找到令其为 False 的反例，或者证明其正确性。注意到这里搜寻的空间是电路在第一次复位后，即不去考虑复位前的 Chaos 状态。
  \item[b.] \verb|assert(expr)|: \\ Assertions are checked during formal verification. The model checker will try to find a counter-example to the assertion or prove its correctness. Note that the search space is the circuit state after the first reset, i.e., without considering the Chaos before the first reset.
\end{itemize}

% 时序性质定义
\subsubsection{Temporal Assertions} 
% ChiselFV 为时序相关的性质描述提供了丰富的支持。
ChiselFV provides rich support for temporal property descriptions.
\begin{itemize}
    % 可以使用 past 语句获取某个信号在 |<num>| 时刻之前的值。
    \item[a.] \verb|past(expr, num)|: \\ It can be used to get the value of a signal at time \verb|<num>| before the current time.
    \item[b.] \verb|assertAfterNStepWhen(cond, num, expr)|: \\ 
    It can be used to assume that when the \verb|cond| is true, the \verb|expr| signal is true in \verb|num| steps.
    % 在 SVA 语法中，类似于语句 |cond -> ##num expr|.
    In SVA syntax, it is similar to the statement \verb|cond -> ##num expr|.
    Additionally, \verb|assertNextStepWhen(cond, expr)| is equivalent to \verb|assertAfterNStepWhen(cond, 1, expr)|.
    \item[c.] \verb|assertAlwaysAfterNStep(cond, num, expr)|: \\
    It can be used to assume that when the \verb|cond| is true, the \verb|expr| is always true after \verb|num| steps. In SVA syntax, it is similar to the statement \verb|cond -> ##[num:] expr|.
\end{itemize}

\subsubsection{Universal Quantification}
% ChiselFV 提供了对于全称量词的支持。虽然在硬件电路中描述的是任意一个固定位长的数字，但是这仍然极大提高了对于性质的表达能力。在底层实现上，等价于一个类似于输入的节点，同时约束每个时刻保持值不变。在 ChiselFV 中可以调用 |anyconst(w)| 来得到一个任意位长为 |w| 的值。
In ChiselFV, we provide support for universal quantification. Although we describe a fixed-width number in hardware circuits, this still greatly improves the expressiveness of property description. In the implementation, we treat it as a node equivalent to an input node and constrain the value to be the same at every clock cycle. In ChiselFV, we can call \verb|anyconst(w)| to get any value of fixed-width \verb|w|.

\subsection{Algorithm Engines}
In ChiselFV, we select three mainstreaming algorithms as backend engines: BMC \cite{biere1999symbolic}, k-induction \cite{sheeran2000checking} and PDR \cite{bradley2011sat} algorithm. 



% \begin{table}[htbp]
% \caption{Table Type Styles}
% \begin{center}
% \begin{tabular}{|c|c|c|c|}
% \hline
% \textbf{Table}&\multicolumn{3}{|c|}{\textbf{Table Column Head}} \\
% \cline{2-4} 
% \textbf{Head} & \textbf{\textit{Table column subhead}}& \textbf{\textit{Subhead}}& \textbf{\textit{Subhead}} \\
% \hline
% copy& More table copy$^{\mathrm{a}}$& &  \\
% \hline
% \multicolumn{4}{l}{$^{\mathrm{a}}$Sample of a Table footnote.}
% \end{tabular}
% \label{tab1}
% \end{center}
% \end{table}

% \begin{figure}[htbp]
% \centerline{\includegraphics{fig1.png}}
% \caption{Example of a figure caption.}
% \label{fig}
% \end{figure}


\bibliographystyle{IEEEtran}
\bibliography{./ref.bib}

\end{document}
